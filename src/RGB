#include <FastLED.h>

// ç¯ç¯é…ç½®
#define MAIN_LED_PIN     19
#define MAIN_NUM_LEDS    60
#define RING_LED_PIN     18
#define RING_NUM_LEDS    16

#define CHIPSET     WS2812B
#define COLOR_ORDER GRB

CRGB mainLeds[MAIN_NUM_LEDS];
CRGB ringLeds[RING_NUM_LEDS];

// äººä½“ä¼ æ„Ÿå™¨å¼•è„š
#define MOTION_SENSOR_PIN 15
const int BOARD_LED_PIN = 2;

// çŠ¶æ€å®šä¹‰
enum SystemState {
  STATE_OFF,
  STATE_WAVE_IN,
  STATE_NORMAL,
  STATE_FADE_OUT
};

SystemState currentState = STATE_OFF;

// å˜é‡å£°æ˜
bool lastMotionState = false;
bool currentMotionState = false;
unsigned long lastMotionTime = 0;

// æ•ˆæœå‚æ•°
const uint16_t WAVE_IN_DURATION = 1800;
const uint16_t FADE_OUT_DURATION = 1200;
const uint8_t TARGET_BRIGHTNESS = 70;

// éé˜»å¡å»¶è¿Ÿå˜é‡
unsigned long previousMillis = 0;
const long UPDATE_INTERVAL = 35;

// è‰²å½©æ¨¡å¼
uint8_t colorMode = 0;
unsigned long lastModeChange = 0;
const long MODE_CHANGE_INTERVAL = 20000; // 20ç§’åˆ‡æ¢æ¨¡å¼

// æ•ˆæœå˜é‡
uint8_t hue = 0;
uint8_t pulseValue = 0;
uint8_t wavePosition = 0;
CRGBPalette16 currentPalette;
uint8_t paletteIndex = 0;

// é¢„å®šä¹‰è‰²ç›˜
DEFINE_GRADIENT_PALETTE( sunset_gp ) {
    0, 120,  0,  0,   // æ·±çº¢
   80, 200, 50,  0,   // æ©™çº¢
  160, 255, 150, 0,   // é‡‘è‰²
  255, 255, 200, 50   // æš–é»„
};

DEFINE_GRADIENT_PALETTE( ocean_gp ) {
    0,  0,  0, 80,    // æ·±è“
   80,  0, 80, 150,   // è“è‰²
  160,  0, 150, 200,  // æµ…è“
  255, 100, 200, 255  // é’è“
};

DEFINE_GRADIENT_PALETTE( forest_gp ) {
    0,  0, 30,  0,    // æ·±ç»¿
   80,  0, 80, 20,    // ç»¿è‰²
  160, 80, 150, 30,   // é»„ç»¿
  255, 150, 200, 50   // æµ…ç»¿
};

DEFINE_GRADIENT_PALETTE( lavender_gp ) {
    0,  30,  0, 50,   // æ·±ç´«
   80,  80, 30, 120,  // ç´«è‰²
  160, 150, 80, 180,  // ç´«çº¢
  255, 200, 150, 220  // æ·¡ç´«
};

CRGBPalette16 palettes[] = {
  sunset_gp,
  ocean_gp, 
  forest_gp,
  lavender_gp
};
const uint8_t PALETTE_COUNT = 4;

// ä¿¡å·ç¨³å®šæ€§å¢å¼º
void stableShow() {
  delayMicroseconds(50);
  FastLED.show();
  delayMicroseconds(50);
}

// æ·¡å‡ºæ•ˆæœ
bool fadeOut() {
  static uint32_t startTime = 0;
  static uint8_t startBrightness = 0;
  
  if (startTime == 0) {
    startTime = millis();
    startBrightness = FastLED.getBrightness();
  }
  
  uint32_t elapsedTime = millis() - startTime;
  if (elapsedTime >= FADE_OUT_DURATION) {
    FastLED.setBrightness(0);
    stableShow();
    startTime = 0;
    return true;
  }
  
  uint8_t brightness = startBrightness * (FADE_OUT_DURATION - elapsedTime) / FADE_OUT_DURATION;
  FastLED.setBrightness(brightness);
  stableShow();
  return false;
}

// æ³¢æµªå¼æ·¡å…¥
bool waveIn() {
  static uint32_t startTime = 0;
  
  if (startTime == 0) {
    startTime = millis();
    FastLED.clear();
    // éšæœºé€‰æ‹©ä¸€ä¸ªè‰²ç›˜
    colorMode = random8(PALETTE_COUNT);
    currentPalette = palettes[colorMode];
  }
  
  uint32_t elapsedTime = millis() - startTime;
  if (elapsedTime >= WAVE_IN_DURATION) {
    FastLED.setBrightness(TARGET_BRIGHTNESS);
    stableShow();
    startTime = 0;
    return true;
  }
  
  uint8_t brightness = TARGET_BRIGHTNESS * elapsedTime / WAVE_IN_DURATION;
  FastLED.setBrightness(brightness);
  
  // æ³¢æµªæ•ˆæœ
  wavePosition = (elapsedTime * 256) / WAVE_IN_DURATION;
  for (int i = 0; i < MAIN_NUM_LEDS; i++) {
    // è®¡ç®—æ¯ä¸ªLEDçš„ä½ç½®åœ¨æ³¢æµªä¸­çš„ç›¸ä½
    uint8_t wave = sin8((i * 10) + wavePosition);
    mainLeds[i] = ColorFromPalette(currentPalette, wave, brightness, LINEARBLEND);
  }
  
  // ç¯å½¢ç¯åŒæ­¥
  for (int i = 0; i < RING_NUM_LEDS; i++) {
    uint8_t wave = sin8((i * 20) + wavePosition);
    ringLeds[i] = ColorFromPalette(currentPalette, wave + 128, brightness, LINEARBLEND);
  }
  
  stableShow();
  return false;
}

// æ›´æ–°ä¸»ç¯æ•ˆæœ
void updateMainEffect() {
  unsigned long currentMillis = millis();
  
  // å®šæœŸåˆ‡æ¢è‰²å½©æ¨¡å¼
  if (currentMillis - lastModeChange > MODE_CHANGE_INTERVAL) {
    colorMode = (colorMode + 1) % PALETTE_COUNT;
    currentPalette = palettes[colorMode];
    lastModeChange = currentMillis;
    
    Serial.print("ğŸ¨ åˆ‡æ¢è‰²å½©æ¨¡å¼: ");
    Serial.println(colorMode);
  }
  
  // ç¼“æ…¢ç§»åŠ¨çš„è‰²ç›˜ç´¢å¼•
  paletteIndex += 1;
  
  // ä¸»ç¯ç¯æ•ˆæœ - ç¼“æ…¢æµåŠ¨çš„è‰²å½©
  for (int i = 0; i < MAIN_NUM_LEDS; i++) {
    // æ¯ä¸ªLEDåœ¨è‰²ç›˜ä¸Šæœ‰è½»å¾®åç§»ï¼Œåˆ›é€ æµåŠ¨æ„Ÿ
    uint8_t colorIndex = paletteIndex + (i * 3);
    mainLeds[i] = ColorFromPalette(currentPalette, colorIndex, TARGET_BRIGHTNESS, LINEARBLEND);
  }
}

// æ›´æ–°ç¯å½¢ç¯æ•ˆæœ
void updateRingEffect() {
  // ç¯å½¢ç¯å‘¼å¸æ•ˆæœï¼Œä¸ä¸»ç¯è‰²å½©åè°ƒä½†ä¸åŒæ­¥
  uint8_t breath = (sin8(millis()/25) + 255) / 2;
  
  for (int i = 0; i < RING_NUM_LEDS; i++) {
    // ä½¿ç”¨ä¸ä¸»ç¯ç›¸åŒè‰²ç›˜ä½†ä¸åŒåŒºåŸŸ
    uint8_t colorIndex = paletteIndex + 128 + (i * 10);
    uint8_t ledBrightness = scale8(breath, TARGET_BRIGHTNESS);
    ringLeds[i] = ColorFromPalette(currentPalette, colorIndex, ledBrightness, LINEARBLEND);
  }
}

void setup() {
  Serial.begin(115200);
  
  pinMode(BOARD_LED_PIN, OUTPUT);
  pinMode(MOTION_SENSOR_PIN, INPUT);
  
  Serial.println("====================================");
  Serial.println("åŒç¯ç¯ç³»ç»Ÿ - åŠ¨æ€è‰²å½©æ¨¡å¼");
  Serial.println("ç­‰å¾…äººä½“ç§»åŠ¨...");
  Serial.println("====================================");
  
  // åˆå§‹åŒ–ä¸¤ä¸ªç¯ç¯
  FastLED.addLeds<CHIPSET, MAIN_LED_PIN, COLOR_ORDER>(mainLeds, MAIN_NUM_LEDS);
  FastLED.addLeds<CHIPSET, RING_LED_PIN, COLOR_ORDER>(ringLeds, RING_NUM_LEDS);
  
  FastLED.setBrightness(0);
  FastLED.clear();
  stableShow();
  
  // è®¾ç½®éšæœºç§å­
  random16_set_seed(millis());
  
  // åˆå§‹åŒ–ç¬¬ä¸€ä¸ªè‰²ç›˜
  currentPalette = palettes[0];
}

void loop() {
  // è¯»å–äººä½“æ£€æµ‹æ¨¡å—çŠ¶æ€
  currentMotionState = digitalRead(MOTION_SENSOR_PIN);
  
  // æ£€æµ‹åˆ°çŠ¶æ€å˜åŒ–
  if (currentMotionState != lastMotionState) {
    lastMotionState = currentMotionState;
    lastMotionTime = millis();
    
    if (currentMotionState) {
      Serial.println("ğŸš¶ æ£€æµ‹åˆ°äººä½“ç§»åŠ¨ï¼");
      digitalWrite(BOARD_LED_PIN, HIGH);
      
      if (currentState == STATE_OFF || currentState == STATE_FADE_OUT) {
        currentState = STATE_WAVE_IN;
      }
    } else {
      Serial.println("ğŸ’¤ æ— äººä½“ç§»åŠ¨");
      digitalWrite(BOARD_LED_PIN, LOW);
      
      if (currentState == STATE_NORMAL) {
        currentState = STATE_FADE_OUT;
      }
    }
  }
  
  // çŠ¶æ€æœºå¤„ç†
  switch (currentState) {
    case STATE_OFF:
      break;
      
    case STATE_WAVE_IN:
      if (waveIn()) {
        currentState = STATE_NORMAL;
        lastModeChange = millis();
      }
      break;
      
    case STATE_NORMAL:
      {
        unsigned long currentMillis = millis();
        if (currentMillis - previousMillis >= UPDATE_INTERVAL) {
          previousMillis = currentMillis;
          
          // æ›´æ–°ä¸»ç¯æ•ˆæœ
          updateMainEffect();
          
          // æ›´æ–°ç¯å½¢ç¯æ•ˆæœ
          updateRingEffect();
          
          stableShow();
        }
      }
      break;
      
    case STATE_FADE_OUT:
      if (fadeOut()) {
        currentState = STATE_OFF;
      }
      break;
  }
  
  // å¦‚æœæ£€æµ‹åˆ°ç§»åŠ¨ï¼Œå®šæœŸè¾“å‡ºçŠ¶æ€
  if (currentMotionState && currentState == STATE_NORMAL) {
    unsigned long currentTime = millis();
    if (currentTime - lastMotionTime > 15000) {
      Serial.println("ğŸ“ äººä½“ä»åœ¨æ£€æµ‹èŒƒå›´å†…");
      lastMotionTime = currentTime;
    }
  }
}