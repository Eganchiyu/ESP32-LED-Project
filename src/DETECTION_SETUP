#include <HardwareSerial.h>

// å®šä¹‰HLK-LD2402é€šä¿¡å‚æ•°
HardwareSerial LD2402(1); // ä½¿ç”¨UART1
const int LD2402_RX_PIN = 16;
const int LD2402_TX_PIN = 17;
const unsigned long BAUDRATE = 115200;

// åè®®å¸§å®šä¹‰
const uint8_t FRAME_HEADER[4] = {0xFD, 0xFC, 0xFB, 0xFA};
const uint8_t FRAME_TAIL[4] = {0x04, 0x03, 0x02, 0x01};

// é—¨é™å€¼è®¡ç®—å‡½æ•°
// dBå€¼è½¬æ¢ä¸ºå‚æ•°å€¼å…¬å¼: M = 10^(N/10)ï¼Œå…¶ä¸­Nä¸ºdBå€¼
uint32_t dbToParamValue(float db) {
  return (uint32_t)powf(10.0f, db / 10.0f);
}

// å‚æ•°å€¼è½¬æ¢ä¸ºdBå€¼
float paramValueToDb(uint32_t value) {
  if (value == 0) return 0;
  return 10.0f * log10f((float)value);
}

// å‘½ä»¤å®šä¹‰
const uint8_t CMD_ENABLE_CONFIG[14] = {0xFD, 0xFC, 0xFB, 0xFA, 0x04, 0x00, 0xFF, 0x00, 0x01, 0x00, 0x04, 0x03, 0x02, 0x01};
const uint8_t CMD_SAVE_PARAMS[14] = {0xFD, 0xFC, 0xFB, 0xFA, 0x02, 0x00, 0xFD, 0x00, 0x04, 0x03, 0x02, 0x01};
const uint8_t CMD_EXIT_CONFIG[14] = {0xFD, 0xFC, 0xFB, 0xFA, 0x02, 0x00, 0xFE, 0x00, 0x04, 0x03, 0x02, 0x01};

// å‡½æ•°å£°æ˜
bool sendCommandAndCheck(const uint8_t* command, int cmdLength);
bool setThreshold(uint8_t param_id, uint32_t value);
bool setDisappearDelay(uint16_t delaySeconds);
bool readThreshold(uint8_t param_id, uint32_t* value);
bool readDisappearDelay(uint16_t* delaySeconds);
void printHexData(const uint8_t* data, int length);
void uint32ToBytes(uint32_t value, uint8_t* bytes);

void setup() {
  Serial.begin(115200);
  LD2402.begin(BAUDRATE, SERIAL_8N1, LD2402_RX_PIN, LD2402_TX_PIN);
  
  // ğŸ¯ åœ¨è¿™é‡Œä¿®æ”¹ç›®æ ‡å‚æ•°å€¼ ğŸ¯
  float targetTriggerDb = 44.0f;    // è§¦å‘é—¨é™ (dB) - ä¿®æ”¹è¿™ä¸ªå€¼
  float targetMicroDb = 40.0f;      // å¾®åŠ¨é—¨é™ (dB) - ä¿®æ”¹è¿™ä¸ªå€¼  
  uint16_t targetDelaySeconds = 2; // ç›®æ ‡æ¶ˆå¤±å»¶è¿Ÿ (ç§’) - ä¿®æ”¹è¿™ä¸ªå€¼
  
  Serial.println("HLK-LD2402 å‚æ•°é…ç½®å¼€å§‹...");
  Serial.printf("ç›®æ ‡é…ç½®ï¼š\n");
  Serial.printf("  - è§¦å‘é—¨é™: %.1fdB\n", targetTriggerDb);
  Serial.printf("  - å¾®åŠ¨é—¨é™: %.1fdB\n", targetMicroDb);
  Serial.printf("  - ç›®æ ‡æ¶ˆå¤±å»¶è¿Ÿ: %dç§’\n", targetDelaySeconds);
  Serial.println("================================");
  
  delay(2000); // ç­‰å¾…æ¨¡å—å¯åŠ¨
  
  // æ­¥éª¤1: è¿›å…¥é…ç½®æ¨¡å¼
  Serial.println("1. è¿›å…¥é…ç½®æ¨¡å¼...");
  if (!sendCommandAndCheck(CMD_ENABLE_CONFIG, sizeof(CMD_ENABLE_CONFIG))) {
    Serial.println("âŒ è¿›å…¥é…ç½®æ¨¡å¼å¤±è´¥ï¼åœæ­¢æ‰§è¡Œ");
    return;
  }
  Serial.println("âœ… è¿›å…¥é…ç½®æ¨¡å¼æˆåŠŸ");
  
  // æ­¥éª¤2: è¯»å–å½“å‰è®¾ç½®
  Serial.println("2. è¯»å–å½“å‰è®¾ç½®...");
  uint32_t currentValue;
  uint16_t currentDelay;
  
  // è¯»å–å½“å‰è§¦å‘é—¨é™0
  if (readThreshold(0x10, &currentValue)) {
    Serial.printf("å½“å‰è§¦å‘é—¨é™0: %.2fdB\n", paramValueToDb(currentValue));
  }
  
  // è¯»å–å½“å‰å¾®åŠ¨é—¨é™0
  if (readThreshold(0x30, &currentValue)) {
    Serial.printf("å½“å‰å¾®åŠ¨é—¨é™0: %.2fdB\n", paramValueToDb(currentValue));
  }
  
  // è¯»å–å½“å‰æ¶ˆå¤±å»¶è¿Ÿ
  if (readDisappearDelay(&currentDelay)) {
    Serial.printf("å½“å‰ç›®æ ‡æ¶ˆå¤±å»¶è¿Ÿ: %dç§’\n", currentDelay);
  }
  
  // æ­¥éª¤3: é…ç½®æ‰€æœ‰è§¦å‘é—¨é™
  Serial.printf("3. é…ç½®è§¦å‘é—¨é™åˆ°%.1fdB...\n", targetTriggerDb);
  uint32_t triggerThreshold = dbToParamValue(targetTriggerDb);
  bool allSuccess = true;
  
  for (int i = 0; i < 16; i++) {
    uint8_t param_id = 0x10 + i; // 0x0010 ~ 0x001F
    if (!setThreshold(param_id, triggerThreshold)) {
      Serial.printf("âŒ é…ç½®è§¦å‘é—¨é™%då¤±è´¥ï¼\n", i);
      allSuccess = false;
      break;
    }
    Serial.printf("âœ… è§¦å‘é—¨é™%d -> %.1fdB\n", i, targetTriggerDb);
    delay(50);
  }
  
  if (!allSuccess) return;
  
  // æ­¥éª¤4: é…ç½®æ‰€æœ‰å¾®åŠ¨é—¨é™
  Serial.printf("4. é…ç½®å¾®åŠ¨é—¨é™åˆ°%.1fdB...\n", targetMicroDb);
  uint32_t microThreshold = dbToParamValue(targetMicroDb);
  
  for (int i = 0; i < 16; i++) {
    uint8_t param_id = 0x30 + i; // 0x0030 ~ 0x003F
    if (!setThreshold(param_id, microThreshold)) {
      Serial.printf("âŒ é…ç½®å¾®åŠ¨é—¨é™%då¤±è´¥ï¼\n", i);
      allSuccess = false;
      break;
    }
    Serial.printf("âœ… å¾®åŠ¨é—¨é™%d -> %.1fdB\n", i, targetMicroDb);
    delay(50);
  }
  
  if (!allSuccess) return;
  
  // æ­¥éª¤5: é…ç½®ç›®æ ‡æ¶ˆå¤±å»¶è¿Ÿ
  Serial.printf("5. é…ç½®ç›®æ ‡æ¶ˆå¤±å»¶è¿Ÿä¸º%dç§’...\n", targetDelaySeconds);
  if (!setDisappearDelay(targetDelaySeconds)) {
    Serial.println("âŒ é…ç½®ç›®æ ‡æ¶ˆå¤±å»¶è¿Ÿå¤±è´¥ï¼");
    return;
  }
  Serial.printf("âœ… ç›®æ ‡æ¶ˆå¤±å»¶è¿Ÿ -> %dç§’\n", targetDelaySeconds);
  
  // æ­¥éª¤6: è¯»å–å¹¶éªŒè¯è®¾ç½®
  Serial.println("6. è¯»å–å¹¶éªŒè¯è®¾ç½®...");
  
  // éªŒè¯è§¦å‘é—¨é™
  if (readThreshold(0x10, &currentValue)) {
    float dbValue = paramValueToDb(currentValue);
    Serial.printf("éªŒè¯è§¦å‘é—¨é™0: %.2fdB %s\n", dbValue, 
                 (fabs(dbValue - targetTriggerDb) < 1.0f) ? "âœ…" : "âŒ");
  }
  
  // éªŒè¯å¾®åŠ¨é—¨é™
  if (readThreshold(0x30, &currentValue)) {
    float dbValue = paramValueToDb(currentValue);
    Serial.printf("éªŒè¯å¾®åŠ¨é—¨é™0: %.2fdB %s\n", dbValue,
                 (fabs(dbValue - targetMicroDb) < 1.0f) ? "âœ…" : "âŒ");
  }
  
  // éªŒè¯æ¶ˆå¤±å»¶è¿Ÿ
  if (readDisappearDelay(&currentDelay)) {
    Serial.printf("éªŒè¯ç›®æ ‡æ¶ˆå¤±å»¶è¿Ÿ: %dç§’ %s\n", currentDelay,
                 (currentDelay == targetDelaySeconds) ? "âœ…" : "âŒ");
  }
  
  // æ­¥éª¤7: ä¿å­˜å‚æ•°
  Serial.println("7. ä¿å­˜å‚æ•°...");
  if (!sendCommandAndCheck(CMD_SAVE_PARAMS, sizeof(CMD_SAVE_PARAMS))) {
    Serial.println("âŒ å‚æ•°ä¿å­˜å¤±è´¥ï¼");
    return;
  }
  Serial.println("âœ… å‚æ•°ä¿å­˜æˆåŠŸ");
  
  // æ­¥éª¤8: é€€å‡ºé…ç½®æ¨¡å¼
  Serial.println("8. é€€å‡ºé…ç½®æ¨¡å¼...");
  if (!sendCommandAndCheck(CMD_EXIT_CONFIG, sizeof(CMD_EXIT_CONFIG))) {
    Serial.println("âŒ é€€å‡ºé…ç½®æ¨¡å¼å¤±è´¥ï¼");
    return;
  }
  Serial.println("âœ… é€€å‡ºé…ç½®æ¨¡å¼æˆåŠŸ");
  
  Serial.println("================================");
  Serial.println("ğŸ‰ æ‰€æœ‰å‚æ•°é…ç½®å®Œæˆï¼");
  Serial.printf("æ¨¡å—å°†åº”ç”¨æ–°è®¾ç½®ï¼š\n");
  Serial.printf("  - è§¦å‘é—¨é™: %.1fdB\n", targetTriggerDb);
  Serial.printf("  - å¾®åŠ¨é—¨é™: %.1fdB\n", targetMicroDb);
  Serial.printf("  - ç›®æ ‡æ¶ˆå¤±å»¶è¿Ÿ: %dç§’\n", targetDelaySeconds);
}

void loop() {
  // ä¸»å¾ªç¯ä¸æ‰§è¡Œä»»ä½•æ“ä½œ
  delay(1000);
}

// å‘é€å‘½ä»¤å¹¶æ£€æŸ¥å“åº”
bool sendCommandAndCheck(const uint8_t* command, int cmdLength) {
  // æ¸…ç©ºæ¥æ”¶ç¼“å†²åŒº
  while (LD2402.available()) {
    LD2402.read();
  }
  
  // å‘é€å‘½ä»¤
  Serial.print("å‘é€å‘½ä»¤: ");
  printHexData(command, cmdLength);
  
  LD2402.write(command, cmdLength);
  LD2402.flush();
  
  // ç­‰å¾…å¹¶è¯»å–å“åº”
  delay(100);
  uint8_t response[30];
  int bytesRead = 0;
  unsigned long startTime = millis();
  
  while (millis() - startTime < 1000 && bytesRead < 30) {
    if (LD2402.available()) {
      response[bytesRead] = LD2402.read();
      bytesRead++;
    }
  }
  
  // æ£€æŸ¥å“åº”æ˜¯å¦æœ‰æ•ˆ
  if (bytesRead >= 10) {
    Serial.print("æ”¶åˆ°å“åº”: ");
    printHexData(response, bytesRead);
    
    // æŸ¥æ‰¾å¸§å¤´ä½ç½®
    int headerPos = -1;
    for (int i = 0; i <= bytesRead - 4; i++) {
      if (memcmp(response + i, FRAME_HEADER, 4) == 0) {
        headerPos = i;
        break;
      }
    }
    
    if (headerPos >= 0) {
      // çŠ¶æ€ç åœ¨å¸§å¤´åçš„ç¬¬8å’Œç¬¬9å­—èŠ‚ï¼ˆå°ç«¯æ ¼å¼ï¼‰
      int statusPos = headerPos + 8;
      if (statusPos + 1 < bytesRead) {
        uint16_t status = (response[statusPos + 1] << 8) | response[statusPos];
        if (status == 0x0000) {
          Serial.println("âœ… å‘½ä»¤æ‰§è¡ŒæˆåŠŸ");
          return true;
        } else {
          Serial.printf("âŒ å‘½ä»¤æ‰§è¡Œå¤±è´¥ï¼ŒçŠ¶æ€ç : 0x%04X\n", status);
        }
      }
    } else {
      Serial.println("âŒ å“åº”å¸§æ ¼å¼é”™è¯¯ï¼Œæœªæ‰¾åˆ°å¸§å¤´");
    }
  } else {
    Serial.println("âŒ æœªæ”¶åˆ°æœ‰æ•ˆå“åº”æˆ–å“åº”è¶…æ—¶");
  }
  
  return false;
}

// è®¾ç½®å•ä¸ªé—¨é™å‚æ•°
bool setThreshold(uint8_t param_id, uint32_t value) {
  uint8_t valueBytes[4];
  uint32ToBytes(value, valueBytes);
  
  uint8_t command[18] = {
    0xFD, 0xFC, 0xFB, 0xFA, // å¸§å¤´
    0x08, 0x00,             // æ•°æ®é•¿åº¦ (8å­—èŠ‚)
    0x07, 0x00,             // å‘½ä»¤å­— (0x0007 - é…ç½®å‚æ•°)
    param_id, 0x00,         // å‚æ•°ID
    valueBytes[0], valueBytes[1], valueBytes[2], valueBytes[3], // å‚æ•°å€¼
    0x04, 0x03, 0x02, 0x01  // å¸§å°¾
  };
  
  return sendCommandAndCheck(command, sizeof(command));
}

// è®¾ç½®ç›®æ ‡æ¶ˆå¤±å»¶è¿Ÿ
bool setDisappearDelay(uint16_t delaySeconds) {
  uint8_t delayBytes[4] = {
    (uint8_t)(delaySeconds & 0xFF),
    (uint8_t)((delaySeconds >> 8) & 0xFF),
    0x00, 0x00
  };
  
  uint8_t command[18] = {
    0xFD, 0xFC, 0xFB, 0xFA, // å¸§å¤´
    0x08, 0x00,             // æ•°æ®é•¿åº¦ (8å­—èŠ‚)
    0x07, 0x00,             // å‘½ä»¤å­— (0x0007 - é…ç½®å‚æ•°)
    0x04, 0x00,             // å‚æ•°ID (0x0004 - ç›®æ ‡æ¶ˆå¤±å»¶è¿Ÿ)
    delayBytes[0], delayBytes[1], delayBytes[2], delayBytes[3], // å‚æ•°å€¼
    0x04, 0x03, 0x02, 0x01  // å¸§å°¾
  };
  
  return sendCommandAndCheck(command, sizeof(command));
}

// è¯»å–é—¨é™å‚æ•°
bool readThreshold(uint8_t param_id, uint32_t* value) {
  uint8_t read_cmd[14] = {
    0xFD, 0xFC, 0xFB, 0xFA, 0x04, 0x00, 0x08, 0x00, 
    param_id, 0x00, 0x04, 0x03, 0x02, 0x01
  };
  
  // æ¸…ç©ºæ¥æ”¶ç¼“å†²åŒº
  while (LD2402.available()) {
    LD2402.read();
  }
  
  // å‘é€è¯»å–å‘½ä»¤
  LD2402.write(read_cmd, sizeof(read_cmd));
  LD2402.flush();
  
  // ç­‰å¾…å¹¶è¯»å–å“åº”
  delay(100);
  uint8_t response[30];
  int bytesRead = 0;
  unsigned long startTime = millis();
  
  while (millis() - startTime < 1000 && bytesRead < 30) {
    if (LD2402.available()) {
      response[bytesRead] = LD2402.read();
      bytesRead++;
    }
  }
  
  // è§£æå“åº”
  if (bytesRead >= 14) {
    // æŸ¥æ‰¾å¸§å¤´ä½ç½®
    int headerPos = -1;
    for (int i = 0; i <= bytesRead - 4; i++) {
      if (memcmp(response + i, FRAME_HEADER, 4) == 0) {
        headerPos = i;
        break;
      }
    }
    
    if (headerPos >= 0 && headerPos + 13 < bytesRead) {
      // å‚æ•°å€¼åœ¨å¸§å¤´åçš„ç¬¬10-13å­—èŠ‚ï¼ˆå°ç«¯æ ¼å¼ï¼‰
      *value = (uint32_t)response[headerPos + 10] |
               ((uint32_t)response[headerPos + 11] << 8) |
               ((uint32_t)response[headerPos + 12] << 16) |
               ((uint32_t)response[headerPos + 13] << 24);
      return true;
    }
  }
  
  return false;
}

// è¯»å–ç›®æ ‡æ¶ˆå¤±å»¶è¿Ÿ
bool readDisappearDelay(uint16_t* delaySeconds) {
  uint8_t read_cmd[14] = {
    0xFD, 0xFC, 0xFB, 0xFA, 0x04, 0x00, 0x08, 0x00, 
    0x04, 0x00, 0x04, 0x03, 0x02, 0x01
  };
  
  // æ¸…ç©ºæ¥æ”¶ç¼“å†²åŒº
  while (LD2402.available()) {
    LD2402.read();
  }
  
  // å‘é€è¯»å–å‘½ä»¤
  LD2402.write(read_cmd, sizeof(read_cmd));
  LD2402.flush();
  
  // ç­‰å¾…å¹¶è¯»å–å“åº”
  delay(100);
  uint8_t response[30];
  int bytesRead = 0;
  unsigned long startTime = millis();
  
  while (millis() - startTime < 1000 && bytesRead < 30) {
    if (LD2402.available()) {
      response[bytesRead] = LD2402.read();
      bytesRead++;
    }
  }
  
  // è§£æå“åº”
  if (bytesRead >= 14) {
    // æŸ¥æ‰¾å¸§å¤´ä½ç½®
    int headerPos = -1;
    for (int i = 0; i <= bytesRead - 4; i++) {
      if (memcmp(response + i, FRAME_HEADER, 4) == 0) {
        headerPos = i;
        break;
      }
    }
    
    if (headerPos >= 0 && headerPos + 11 < bytesRead) {
      // å‚æ•°å€¼åœ¨å¸§å¤´åçš„ç¬¬10-11å­—èŠ‚ï¼ˆå°ç«¯æ ¼å¼ï¼‰
      *delaySeconds = (uint16_t)response[headerPos + 10] |
                     ((uint16_t)response[headerPos + 11] << 8);
      return true;
    }
  }
  
  return false;
}

// æ‰“å°åå…­è¿›åˆ¶æ•°æ®ï¼ˆç”¨äºè°ƒè¯•ï¼‰
void printHexData(const uint8_t* data, int length) {
  for (int i = 0; i < length; i++) {
    Serial.printf("%02X ", data[i]);
  }
  Serial.println();
}

// å°†32ä½æ•´æ•°è½¬æ¢ä¸ºå°ç«¯å­—èŠ‚åºåˆ—
void uint32ToBytes(uint32_t value, uint8_t* bytes) {
  bytes[0] = (uint8_t)(value & 0xFF);
  bytes[1] = (uint8_t)((value >> 8) & 0xFF);
  bytes[2] = (uint8_t)((value >> 16) & 0xFF);
  bytes[3] = (uint8_t)((value >> 24) & 0xFF);
}