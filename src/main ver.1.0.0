
#include <FastLED.h>

// ç¯ç¯é…ç½®
#define MAIN_LED_PIN     19
#define MAIN_NUM_LEDS    60
#define RING_LED_PIN     18
#define RING_NUM_LEDS    16

#define CHIPSET     WS2812B
#define COLOR_ORDER GRB

CRGB mainLeds[MAIN_NUM_LEDS];
CRGB ringLeds[RING_NUM_LEDS];

// äººä½“ä¼ æ„Ÿå™¨å¼•è„š
#define MOTION_SENSOR_PIN 15
const int BOARD_LED_PIN = 2;

// çŠ¶æ€å®šä¹‰
enum SystemState {
  STATE_OFF,
  STATE_BREATHE,
  STATE_FADE_IN,
  STATE_NORMAL,
  STATE_FADE_OUT
};

SystemState currentState = STATE_OFF;

// å˜é‡å£°æ˜
bool lastMotionState = false;
bool currentMotionState = false;
unsigned long lastMotionTime = 0;
unsigned long lastModeChangeTime = 0;

// å‘¼å¸æ•ˆæœå‚æ•°
static uint16_t breatheStep = 0;
const uint16_t BREATHE_STEPS = 120;
const uint16_t BREATHE_DURATION_MS = 750;
const uint16_t STEP_DELAY = BREATHE_DURATION_MS / BREATHE_STEPS;

// äº®åº¦å‚æ•°
const uint16_t FADE_IN_MS = 1000;
const uint16_t FADE_OUT_MS = 1000;
const uint8_t TARGET_BRIGHTNESS = 80;

// éé˜»å¡å»¶è¿Ÿå˜é‡
unsigned long previousMillis = 0;
const long NORMAL_UPDATE_INTERVAL = 30;

// ç¯å½¢ç¯æ•ˆæœå˜é‡
uint8_t ringMode = 0;
uint8_t ringHue = 0;
uint8_t ringPosition = 0;

// æ–°å¢ï¼šå½©è™¹æ•ˆæœèµ·å§‹è‰²è°ƒï¼Œç¡®ä¿ä»æ·¡å…¥åˆ°æ­£å¸¸çš„å¹³æ»‘è¿‡æ¸¡
uint8_t startHue = 0;

// ä¿¡å·ç¨³å®šæ€§å¢å¼º
void stableShow() {
  delayMicroseconds(50);
  FastLED.show();
  delayMicroseconds(50);
}

// æ·¡å‡ºæ•ˆæœ
bool fadeOut() {
  static uint32_t startTime = 0;
  static uint8_t startBrightness = 0;
  
  if (startTime == 0) {
    startTime = millis();
    startBrightness = FastLED.getBrightness();
  }
  
  uint32_t elapsedTime = millis() - startTime;
  if (elapsedTime >= FADE_OUT_MS) {
    FastLED.setBrightness(0);
    stableShow();
    startTime = 0;
    return true;
  }
  
  uint8_t brightness = startBrightness * (FADE_OUT_MS - elapsedTime) / FADE_OUT_MS;
  FastLED.setBrightness(brightness);
  stableShow();
  return false;
}

// ä¿®æ”¹åçš„æ·¡å…¥æ•ˆæœ - ä½¿ç”¨å›ºå®šçš„èµ·å§‹è‰²è°ƒ
bool fadeIn() {
  static uint32_t startTime = 0;
  
  if (startTime == 0) {
    startTime = millis();
    // ä½¿ç”¨å›ºå®šçš„èµ·å§‹è‰²è°ƒï¼Œç¡®ä¿æ¯æ¬¡æ·¡å…¥éƒ½ä»ç›¸åŒä½ç½®å¼€å§‹
    startHue = 0; // é‡ç½®èµ·å§‹è‰²è°ƒ
    fill_rainbow(mainLeds, MAIN_NUM_LEDS, startHue, 255 / MAIN_NUM_LEDS);
    fill_rainbow(ringLeds, RING_NUM_LEDS, startHue + 64, 255 / RING_NUM_LEDS);
    
    // åˆå§‹åŒ–å…¨å±€è‰²è°ƒå˜é‡ï¼Œç¡®ä¿å¹³æ»‘è¿‡æ¸¡
    ringHue = startHue;
  }
  
  uint32_t elapsedTime = millis() - startTime;
  if (elapsedTime >= FADE_IN_MS) {
    FastLED.setBrightness(TARGET_BRIGHTNESS);
    stableShow();
    startTime = 0;
    return true;
  }
  
  uint8_t brightness = TARGET_BRIGHTNESS * elapsedTime / FADE_IN_MS;
  FastLED.setBrightness(brightness);
  
  // åœ¨æ·¡å…¥è¿‡ç¨‹ä¸­ä¿æŒé¢œè‰²ä¸å˜
  fill_rainbow(mainLeds, MAIN_NUM_LEDS, startHue, 255 / MAIN_NUM_LEDS);
  fill_rainbow(ringLeds, RING_NUM_LEDS, startHue + 64, 255 / RING_NUM_LEDS);
  
  stableShow();
  return false;
}

// ç¯å½¢ç¯æ•ˆæœå‡½æ•°
void updateRingLeds() {
  switch(ringMode) {
    case 0: // åŒæ­¥ä¸»ç¯
      break;
      
    case 1: // ç‹¬ç«‹å‘¼å¸æ•ˆæœ
      break;
      
    case 2: // ä¸è¦æ—‹è½¬äº†
      break;
      
    case 3: // ç¯å½¢å½©è™¹ - ä¿®å¤ç‰ˆ
      break;
  }
}

void setup() {
  Serial.begin(115200);
  
  pinMode(BOARD_LED_PIN, OUTPUT);
  pinMode(MOTION_SENSOR_PIN, INPUT);
  
  Serial.println("====================================");
  Serial.println("åŒç¯ç¯ç³»ç»Ÿå¯åŠ¨ - å¹³æ»‘è¿‡æ¸¡ç‰ˆ");
  Serial.println("ç­‰å¾…äººä½“ç§»åŠ¨...");
  Serial.println("====================================");
  
  // åˆå§‹åŒ–ä¸¤ä¸ªç¯ç¯
  FastLED.addLeds<CHIPSET, MAIN_LED_PIN, COLOR_ORDER>(mainLeds, MAIN_NUM_LEDS);
  FastLED.addLeds<CHIPSET, RING_LED_PIN, COLOR_ORDER>(ringLeds, RING_NUM_LEDS);
  
  // è®¾ç½®æ›´ä¿å®ˆçš„å‚æ•°
  FastLED.setBrightness(0);
  
  // åˆå§‹åŒ–æ‰€æœ‰LEDä¸ºé»‘è‰²
  FastLED.clear();
  stableShow();
  
  // åˆå§‹åŒ–è‰²è°ƒå˜é‡
  startHue = 0;
  ringHue = 0;
  
  // æµ‹è¯•ç¯å½¢ç¯ç¯
  Serial.println("æµ‹è¯•ç¯å½¢ç¯ç¯...");
  for (int i = 0; i < RING_NUM_LEDS; i++) {
    ringLeds[i] = CRGB::Blue;
    stableShow();
    delay(100);
    ringLeds[i] = CRGB::Black;
  }
  stableShow();
}

void loop() {
  // è¯»å–äººä½“æ£€æµ‹æ¨¡å—çŠ¶æ€
  currentMotionState = digitalRead(MOTION_SENSOR_PIN);
  
  // æ£€æµ‹åˆ°çŠ¶æ€å˜åŒ–
  if (currentMotionState != lastMotionState) {
    lastMotionState = currentMotionState;
    lastMotionTime = millis();
    
    if (currentMotionState) {
      Serial.println("ğŸš¶ æ£€æµ‹åˆ°äººä½“ç§»åŠ¨ï¼");
      digitalWrite(BOARD_LED_PIN, HIGH);
      
      if (currentState == STATE_OFF || currentState == STATE_FADE_OUT) {
        currentState = STATE_BREATHE;
        breatheStep = 0;
        // é‡ç½®è‰²è°ƒï¼Œç¡®ä¿æ¯æ¬¡é‡æ–°æ£€æµ‹éƒ½ä»ç›¸åŒä½ç½®å¼€å§‹
        startHue = 0;
        ringHue = 0;
      }
    } else {
      Serial.println("ğŸ’¤ æ— äººä½“ç§»åŠ¨");
      digitalWrite(BOARD_LED_PIN, LOW);
      
      if (currentState == STATE_NORMAL) {
        currentState = STATE_FADE_OUT;
      }
    }
  }
  
  // çŠ¶æ€æœºå¤„ç†
  switch (currentState) {
    case STATE_OFF:
      break;
      
    case STATE_BREATHE:
      if (breatheStep < BREATHE_STEPS) {
        FastLED.setBrightness(255);
        FastLED.clear();
        
        // ä¸»ç¯ç¯å‘¼å¸æ•ˆæœ
        uint8_t mainPos = (breatheStep < MAIN_NUM_LEDS) ? breatheStep : (2 * MAIN_NUM_LEDS - 1 - breatheStep);
        uint8_t mainBrightness;
        if (breatheStep < MAIN_NUM_LEDS) {
          mainBrightness = (uint16_t)breatheStep * 255 / MAIN_NUM_LEDS;
        } else {
          mainBrightness = (uint16_t)(BREATHE_STEPS - breatheStep) * 255 / MAIN_NUM_LEDS;
        }
        mainLeds[mainPos] = CRGB(mainBrightness, mainBrightness, mainBrightness);
        
        // ç¯å½¢ç¯ç¯åŒæ­¥å‘¼å¸æ•ˆæœ
        uint8_t ringPos = (breatheStep * RING_NUM_LEDS) / BREATHE_STEPS;
        ringPos = ringPos % RING_NUM_LEDS;
        fill_solid(ringLeds, RING_NUM_LEDS, CRGB::Black);
        ringLeds[ringPos] = CRGB(mainBrightness, mainBrightness, mainBrightness);
        
        stableShow();
        delay(STEP_DELAY);
        breatheStep++;
      } else {
        currentState = STATE_FADE_IN;
        // ç¡®ä¿æ·¡å…¥æ•ˆæœä½¿ç”¨å›ºå®šçš„èµ·å§‹è‰²è°ƒ
        startHue = 0;
      }
      break;
      
    case STATE_FADE_IN:
      if (fadeIn()) {
        currentState = STATE_NORMAL;
        lastModeChangeTime = millis();
        // ä»æ·¡å…¥çš„å›ºå®šè‰²è°ƒå¹³æ»‘è¿‡æ¸¡åˆ°æµåŠ¨å½©è™¹
        ringHue = startHue; // ç¡®ä¿è‰²è°ƒè¿ç»­
      }
      break;
      
    case STATE_NORMAL:
      {
        unsigned long currentMillis = millis();
        if (currentMillis - previousMillis >= NORMAL_UPDATE_INTERVAL) {
          previousMillis = currentMillis;
          
          // ä½¿ç”¨å…¨å±€è‰²è°ƒå˜é‡ï¼Œç¡®ä¿ä»æ·¡å…¥æ•ˆæœå¹³æ»‘è¿‡æ¸¡
          fill_rainbow(mainLeds, MAIN_NUM_LEDS, ringHue, 255 / MAIN_NUM_LEDS);
          fill_rainbow(ringLeds, RING_NUM_LEDS, ringHue + 64, 255 / RING_NUM_LEDS);
          ringHue += 2; // ç¨å¾®å‡æ…¢å˜åŒ–é€Ÿåº¦ï¼Œä½¿è¿‡æ¸¡æ›´å¹³æ»‘
          
          stableShow();
        }
      }
      break;
      
    case STATE_FADE_OUT:
      if (fadeOut()) {
        currentState = STATE_OFF;
        breatheStep = 0;
      }
      break;
  }
  
  // å¦‚æœæ£€æµ‹åˆ°ç§»åŠ¨ï¼Œå®šæœŸè¾“å‡ºçŠ¶æ€
  if (currentMotionState) {
    unsigned long currentTime = millis();
    if (currentTime - lastMotionTime > 5000) {
      Serial.println("ğŸ“ äººä½“ä»åœ¨æ£€æµ‹èŒƒå›´å†…");
      lastMotionTime = currentTime;
    }
  }
}