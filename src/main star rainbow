#include <FastLED.h>

// ç¯ç¯é…ç½®
#define MAIN_LED_PIN     19
#define MAIN_NUM_LEDS    60
#define RING_LED_PIN     18
#define RING_NUM_LEDS    16

#define CHIPSET     WS2812B
#define COLOR_ORDER GRB

CRGB mainLeds[MAIN_NUM_LEDS];
CRGB ringLeds[RING_NUM_LEDS];

// äººä½“ä¼ æ„Ÿå™¨å¼•è„š
#define MOTION_SENSOR_PIN 15
const int BOARD_LED_PIN = 2;

// çŠ¶æ€å®šä¹‰
enum SystemState {
  STATE_OFF,
  STATE_BREATHE,
  STATE_WAKE_UP,
  STATE_NORMAL,
  STATE_FADE_OUT
};

SystemState currentState = STATE_OFF;

// å˜é‡å£°æ˜
bool lastMotionState = false;
bool currentMotionState = false;
unsigned long lastMotionTime = 0;
unsigned long lastModeChangeTime = 0;

// å‘¼å¸æ•ˆæœå‚æ•°
static uint16_t breatheStep = 0;
const uint16_t BREATHE_STEPS = 60; // å‡å°‘æ­¥æ•°ä½¿å‘¼å¸æ›´å¿«
const uint16_t BREATHE_DURATION_MS = 600; // ç¼©çŸ­å‘¼å¸å‘¨æœŸ
const uint16_t STEP_DELAY = BREATHE_DURATION_MS / BREATHE_STEPS;

// äº®åº¦å‚æ•°
const uint16_t WAKE_UP_DURATION = 2000; // ä¸»ç¯æ‰©æ•£æ—¶é—´
const uint16_t FADE_OUT_DURATION = 1500; // æ·¡å‡ºæ—¶é—´
const uint8_t TARGET_BRIGHTNESS = 100; // ä¸»ç¯äº®åº¦

// éé˜»å¡å»¶è¿Ÿå˜é‡
unsigned long previousMillis = 0;
const long UPDATE_INTERVAL = 30;

// è‡ªç„¶å…‰å‚æ•°
const uint8_t WARM_WHITE_HUE = 30;
const uint8_t WARM_WHITE_SATURATION = 50;

// æ˜Ÿå…‰ç³»ç»Ÿå‚æ•°
const uint8_t MAX_STARS = 8;
unsigned long lastStarSpawn = 0;
const long STAR_SPAWN_INTERVAL = 800;

// æ˜Ÿå…‰ç‚¹æ•°æ®ç»“æ„
struct Star {
  int position;
  uint8_t hue;
  uint8_t saturation;
  uint8_t brightness;
  uint8_t targetBrightness;
  unsigned long birthTime;
  unsigned long lifeDuration;
  uint16_t fadeInDuration;
  uint16_t fadeOutDuration;
  bool active;
  uint8_t phase;
};

Star stars[MAX_STARS];

// å½©è™¹æ•ˆæœå˜é‡
uint8_t rainbowHue = 0;

// ä¿¡å·ç¨³å®šæ€§å¢å¼º
void stableShow() {
  delayMicroseconds(50);
  FastLED.show();
  delayMicroseconds(50);
}

// åˆå§‹åŒ–æ˜Ÿå…‰ç³»ç»Ÿ
void initStarSystem() {
  for (int i = 0; i < MAX_STARS; i++) {
    stars[i].active = false;
  }
}

// è·å–æ´»è·ƒæ˜Ÿå…‰ç‚¹æ•°
uint8_t getActiveStarCount() {
  uint8_t count = 0;
  for (int i = 0; i < MAX_STARS; i++) {
    if (stars[i].active) count++;
  }
  return count;
}

// ç”Ÿæˆæ–°çš„æ˜Ÿå…‰ç‚¹
void spawnStar() {
  for (int i = 0; i < MAX_STARS; i++) {
    if (!stars[i].active) {
      bool positionValid = false;
      int attempts = 0;
      
      while (!positionValid && attempts < 20) {
        stars[i].position = random16(RING_NUM_LEDS);
        positionValid = true;
        
        for (int j = 0; j < MAX_STARS; j++) {
          if (j != i && stars[j].active) {
            int distance = abs(stars[i].position - stars[j].position);
            if (distance <= 2) {
              positionValid = false;
              break;
            }
          }
        }
        attempts++;
      }
      
      stars[i].hue = WARM_WHITE_HUE + random8(20) - 10;
      stars[i].saturation = 20 + random8(30);
      stars[i].brightness = 0;
      stars[i].targetBrightness = 200 + random8(55); // æ˜Ÿå…‰äº®åº¦ä¿æŒ255
      stars[i].birthTime = millis();
      stars[i].lifeDuration = 3000 + random16(7000);
      stars[i].fadeInDuration = 800 + random16(1200);
      stars[i].fadeOutDuration = 1000 + random16(2000);
      stars[i].phase = 0;
      stars[i].active = true;
      
      Serial.print("âœ¨ æ–°ç”Ÿæ˜Ÿç‚¹ #");
      Serial.print(i);
      Serial.print(" ä½ç½®:");
      Serial.print(stars[i].position);
      Serial.print(" äº®åº¦:");
      Serial.print(stars[i].targetBrightness);
      Serial.println("");
      break;
    }
  }
}

// æ›´æ–°æ˜Ÿå…‰ç‚¹çŠ¶æ€
void updateStars() {
  unsigned long currentTime = millis();
  
  for (int i = 0; i < MAX_STARS; i++) {
    if (stars[i].active) {
      unsigned long starAge = currentTime - stars[i].birthTime;
      
      if (starAge > stars[i].lifeDuration) {
        stars[i].active = false;
        continue;
      }
      
      switch (stars[i].phase) {
        case 0: // æ·¡å…¥é˜¶æ®µ
          if (starAge < stars[i].fadeInDuration) {
            uint16_t progress = (starAge * 256) / stars[i].fadeInDuration;
            stars[i].brightness = (stars[i].targetBrightness * progress) / 256;
          } else {
            stars[i].brightness = stars[i].targetBrightness;
            stars[i].phase = 1;
          }
          break;
          
        case 1: // ç¨³å®šé˜¶æ®µ
          if (starAge > stars[i].lifeDuration - stars[i].fadeOutDuration) {
            stars[i].phase = 2;
          }
          break;
          
        case 2: // æ·¡å‡ºé˜¶æ®µ
          {
            unsigned long timeInFadeOut = starAge - (stars[i].lifeDuration - stars[i].fadeOutDuration);
            uint16_t progress = (timeInFadeOut * 256) / stars[i].fadeOutDuration;
            stars[i].brightness = stars[i].targetBrightness - ((stars[i].targetBrightness * progress) / 256);
          }
          break;
      }
    }
  }
}

// æ¸²æŸ“æ˜Ÿå…‰ç‚¹åˆ°ç¯å½¢ç¯
void renderStars() {
  fill_solid(ringLeds, RING_NUM_LEDS, CRGB::Black);
  
  for (int i = 0; i < MAX_STARS; i++) {
    if (stars[i].active) {
      ringLeds[stars[i].position] = CHSV(stars[i].hue, stars[i].saturation, stars[i].brightness);
    }
  }
}

// å°è¯•ç”Ÿæˆæ–°æ˜Ÿ
void trySpawnStar() {
  unsigned long currentTime = millis();
  
  if (currentTime - lastStarSpawn > STAR_SPAWN_INTERVAL) {
    lastStarSpawn = currentTime;
    
    uint8_t activeCount = getActiveStarCount();
    uint8_t spawnChance = 0;
    
    if (activeCount < 3) spawnChance = 80;
    else if (activeCount < 5) spawnChance = 50;
    else if (activeCount < 7) spawnChance = 20;
    
    if (random8(100) < spawnChance) {
      spawnStar();
    }
  }
}

// ç¨³å®šçš„æš–ç™½è‰²è°ƒ
CRGB getWarmWhite() {
  return CHSV(WARM_WHITE_HUE, WARM_WHITE_SATURATION, TARGET_BRIGHTNESS);
}

// å‘¼å¸æ•ˆæœ
bool breatheEffect() {
  static unsigned long lastBreatheTime = 0;
  unsigned long currentTime = millis();
  
  if (currentTime - lastBreatheTime >= STEP_DELAY) {
    lastBreatheTime = currentTime;
    
    if (breatheStep < BREATHE_STEPS) {
      FastLED.setBrightness(255);
      FastLED.clear();
      
      // ä¸»ç¯ç¯å‘¼å¸æ•ˆæœ
      uint8_t mainPos = (breatheStep < MAIN_NUM_LEDS) ? breatheStep : (2 * MAIN_NUM_LEDS - 1 - breatheStep);
      uint8_t mainBrightness;
      if (breatheStep < MAIN_NUM_LEDS) {
        mainBrightness = (uint16_t)breatheStep * 255 / MAIN_NUM_LEDS;
      } else {
        mainBrightness = (uint16_t)(BREATHE_STEPS - breatheStep) * 255 / MAIN_NUM_LEDS;
      }
      mainLeds[mainPos] = CRGB(mainBrightness, mainBrightness, mainBrightness);
      
      // ç¯å½¢ç¯ç¯åŒæ­¥å‘¼å¸æ•ˆæœ
      uint8_t ringPos = (breatheStep * RING_NUM_LEDS) / BREATHE_STEPS;
      ringPos = ringPos % RING_NUM_LEDS;
      fill_solid(ringLeds, RING_NUM_LEDS, CRGB::Black);
      ringLeds[ringPos] = CRGB(mainBrightness, mainBrightness, mainBrightness);
      
      stableShow();
      breatheStep++;
    } else {
      breatheStep = 0;
      return true;
    }
  }
  return false;
}

// ä¸»ç¯æ‰©æ•£æ•ˆæœ
bool wakeUp() {
  static uint32_t startTime = 0;
  
  if (startTime == 0) {
    startTime = millis();
    fill_solid(mainLeds, MAIN_NUM_LEDS, CRGB::Black);
    fill_solid(ringLeds, RING_NUM_LEDS, CRGB::Black);
    initStarSystem();
  }
  
  uint32_t elapsedTime = millis() - startTime;
  if (elapsedTime >= WAKE_UP_DURATION) {
    FastLED.setBrightness(TARGET_BRIGHTNESS);
    stableShow();
    startTime = 0;
    return true;
  }
  
  uint8_t brightness = TARGET_BRIGHTNESS * elapsedTime / WAKE_UP_DURATION;
  FastLED.setBrightness(brightness);
  
  // ä»ä¸­å¿ƒå‘å¤–æ‰©æ•£æš–ç™½å…‰
  uint8_t progress = (elapsedTime * 256) / WAKE_UP_DURATION;
  uint8_t litLeds = scale8(MAIN_NUM_LEDS, progress);
  
  fill_solid(mainLeds, MAIN_NUM_LEDS, CRGB::Black);
  for (int i = 0; i < litLeds; i++) {
    int pos1 = (MAIN_NUM_LEDS/2) + i/2;
    int pos2 = (MAIN_NUM_LEDS/2) - i/2;
    if (pos1 < MAIN_NUM_LEDS) mainLeds[pos1] = getWarmWhite();
    if (pos2 >= 0) mainLeds[pos2] = getWarmWhite();
  }
  
  // ç¯å½¢ç¯ä¿æŒé»‘è‰²ï¼Œç­‰å¾…æ˜Ÿå…‰æ•ˆæœ
  fill_solid(ringLeds, RING_NUM_LEDS, CRGB::Black);
  
  stableShow();
  return false;
}

// æ·¡å‡ºæ•ˆæœ
bool fadeOut() {
  static uint32_t startTime = 0;
  static uint8_t startBrightness = 0;
  
  if (startTime == 0) {
    startTime = millis();
    startBrightness = FastLED.getBrightness();
    initStarSystem();
  }
  
  uint32_t elapsedTime = millis() - startTime;
  if (elapsedTime >= FADE_OUT_DURATION) {
    FastLED.setBrightness(0);
    stableShow();
    startTime = 0;
    return true;
  }
  
  uint8_t brightness = startBrightness * (FADE_OUT_DURATION - elapsedTime) / FADE_OUT_DURATION;
  FastLED.setBrightness(brightness);
  stableShow();
  return false;
}

void setup() {
  Serial.begin(115200);
  
  pinMode(BOARD_LED_PIN, OUTPUT);
  pinMode(MOTION_SENSOR_PIN, INPUT);
  
  Serial.println("====================================");
  Serial.println("åŒç¯ç¯ç³»ç»Ÿ - å®Œæ•´æ˜Ÿå…‰æ¨¡å¼");
  Serial.println("ç­‰å¾…äººä½“ç§»åŠ¨...");
  Serial.println("====================================");
  
  // åˆå§‹åŒ–ä¸¤ä¸ªç¯ç¯
  FastLED.addLeds<CHIPSET, MAIN_LED_PIN, COLOR_ORDER>(mainLeds, MAIN_NUM_LEDS);
  FastLED.addLeds<CHIPSET, RING_LED_PIN, COLOR_ORDER>(ringLeds, RING_NUM_LEDS);
  
  FastLED.setBrightness(0);
  FastLED.clear();
  stableShow();
  
  // åˆå§‹åŒ–æ˜Ÿå…‰ç³»ç»Ÿ
  initStarSystem();
  
  // è®¾ç½®éšæœºç§å­
  random16_set_seed(millis());
}

void loop() {
  // è¯»å–äººä½“æ£€æµ‹æ¨¡å—çŠ¶æ€
  currentMotionState = digitalRead(MOTION_SENSOR_PIN);
  
  // æ£€æµ‹åˆ°çŠ¶æ€å˜åŒ–
  if (currentMotionState != lastMotionState) {
    lastMotionState = currentMotionState;
    lastMotionTime = millis();
    
    if (currentMotionState) {
      Serial.println("ğŸš¶ æ£€æµ‹åˆ°äººä½“ç§»åŠ¨ï¼");
      digitalWrite(BOARD_LED_PIN, HIGH);
      
      if (currentState == STATE_OFF || currentState == STATE_FADE_OUT) {
        currentState = STATE_BREATHE;
        breatheStep = 0;
      }
    } else {
      Serial.println("ğŸ’¤ æ— äººä½“ç§»åŠ¨");
      digitalWrite(BOARD_LED_PIN, LOW);
      
      if (currentState == STATE_NORMAL) {
        currentState = STATE_FADE_OUT;
      }
    }
  }
  
  // çŠ¶æ€æœºå¤„ç†
  switch (currentState) {
    case STATE_OFF:
      break;
      
    case STATE_BREATHE:
      if (breatheEffect()) {
        currentState = STATE_WAKE_UP;
        Serial.println("ğŸŒ… è¿›å…¥ä¸»ç¯æ‰©æ•£æ¨¡å¼");
      }
      break;
      
    case STATE_WAKE_UP:
      if (wakeUp()) {
        currentState = STATE_NORMAL;
        lastStarSpawn = millis();
        rainbowHue = 0;
        Serial.println("ğŸŒˆ è¿›å…¥æ­£å¸¸æ¨¡å¼ï¼šä¸»ç¯å½©è™¹ + ç¯å½¢æ˜Ÿå…‰");
      }
      break;
      
    case STATE_NORMAL:
      {
        unsigned long currentMillis = millis();
        if (currentMillis - previousMillis >= UPDATE_INTERVAL) {
          previousMillis = currentMillis;
          
          // ä¸»ç¯ç¯ - æµåŠ¨å½©è™¹æ•ˆæœï¼Œäº®åº¦100
          fill_rainbow(mainLeds, MAIN_NUM_LEDS, rainbowHue, 255 / MAIN_NUM_LEDS);
          rainbowHue += 1;
          
          // æ˜Ÿå…‰ç³»ç»Ÿæ›´æ–° - äº®åº¦ä¿æŒ255
          trySpawnStar();
          updateStars();
          renderStars();
          
          stableShow();
        }
      }
      break;
      
    case STATE_FADE_OUT:
      if (fadeOut()) {
        currentState = STATE_OFF;
        Serial.println("ğŸŒ™ ç³»ç»Ÿå·²å…³é—­");
      }
      break;
  }
  
  // å¦‚æœæ£€æµ‹åˆ°ç§»åŠ¨ï¼Œå®šæœŸè¾“å‡ºçŠ¶æ€
  if (currentMotionState && currentState == STATE_NORMAL) {
    unsigned long currentTime = millis();
    if (currentTime - lastMotionTime > 15000) {
      uint8_t starCount = getActiveStarCount();
      Serial.print("ğŸ“ äººä½“ä»åœ¨æ£€æµ‹èŒƒå›´å†…ï¼Œæ´»è·ƒæ˜Ÿç‚¹:");
      Serial.println(starCount);
      lastMotionTime = currentTime;
    }
  }
}