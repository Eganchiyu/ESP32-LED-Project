#include <FastLED.h>
#include <WiFi.h>
#include <WebServer.h>
#include <ArduinoJson.h>

// WiFié…ç½®
const char* ssid = "åŸºæ²ƒæ‰˜æ–¯";
const char* password = "1111111q";

// IPåœ°å€é…ç½®ï¼ˆå¯é€‰ï¼‰
IPAddress local_IP(192, 168, 31, 100);  // è®¾ç½®ESP32çš„é™æ€IP
IPAddress gateway(192, 168, 31, 1);     // è®¾ç½®ç½‘å…³
IPAddress subnet(255, 255, 255, 0);    // è®¾ç½®å­ç½‘æ©ç 

// åˆ›å»ºWebæœåŠ¡å™¨å¯¹è±¡ï¼Œç«¯å£80
WebServer server(80);

// ç¯ç¯é…ç½®
#define MAIN_LED_PIN     19
#define MAIN_NUM_LEDS    60
#define RING_LED_PIN     18
#define RING_NUM_LEDS    16

#define CHIPSET     WS2812B
#define COLOR_ORDER GRB

CRGB mainLeds[MAIN_NUM_LEDS];
CRGB ringLeds[RING_NUM_LEDS];

// äººä½“ä¼ æ„Ÿå™¨å¼•è„š
#define MOTION_SENSOR_PIN 15
const int BOARD_LED_PIN = 2;

// çŠ¶æ€å®šä¹‰
enum SystemState {
  STATE_BREATHE_LOOP,
  STATE_OFF,
  STATE_BREATHE,
  STATE_FADE_IN,
  STATE_NORMAL,
  STATE_FADE_OUT,
  STATE_MANUAL  // æ–°å¢æ‰‹åŠ¨æ§åˆ¶æ¨¡å¼
};

SystemState currentState = STATE_OFF;

// å˜é‡å£°æ˜
bool lastMotionState = false;
bool currentMotionState = false;
unsigned long lastMotionTime = 0;
unsigned long lastModeChangeTime = 0;

// å‘¼å¸æ•ˆæœå‚æ•°
static uint16_t breatheStep = 0;
const uint16_t BREATHE_STEPS = 120;
const uint16_t BREATHE_DURATION_MS = 750;
const uint16_t STEP_DELAY = BREATHE_DURATION_MS / BREATHE_STEPS;

// äº®åº¦å‚æ•°
uint8_t TARGET_BRIGHTNESS = 80;  // æ”¹ä¸ºå˜é‡ï¼Œå¯é€šè¿‡ç½‘é¡µæ§åˆ¶
const uint16_t FADE_IN_MS = 1000;
const uint16_t FADE_OUT_MS = 1000;

// éé˜»å¡å»¶è¿Ÿå˜é‡
unsigned long previousMillis = 0;
const long NORMAL_UPDATE_INTERVAL = 30;

// ç¯å½¢ç¯æ•ˆæœå˜é‡
uint8_t ringMode = 0;
uint8_t ringHue = 0;
uint8_t ringPosition = 0;

// æ–°å¢ï¼šå½©è™¹æ•ˆæœèµ·å§‹è‰²è°ƒï¼Œç¡®ä¿ä»æ·¡å…¥åˆ°æ­£å¸¸çš„å¹³æ»‘è¿‡æ¸¡
uint8_t startHue = 0;

// æ‰‹åŠ¨æ§åˆ¶å‚æ•°
uint8_t manualRed = 255;
uint8_t manualGreen = 255;
uint8_t manualBlue = 255;
bool manualModeActive = false;

// å…¨å±€äº®åº¦æ§åˆ¶
uint8_t globalBrightness = TARGET_BRIGHTNESS;

// WiFiè¿æ¥çŠ¶æ€
bool wifiConnected = false;

// ä¿¡å·ç¨³å®šæ€§å¢å¼º
void stableShow() {
  delayMicroseconds(50);
  FastLED.show();
  delayMicroseconds(50);
}

// æ·¡å‡ºæ•ˆæœ
bool fadeOut() {
  static uint32_t startTime = 0;
  static uint8_t startBrightness = 0;
  
  if (startTime == 0) {
    startTime = millis();
    startBrightness = FastLED.getBrightness();
  }
  
  uint32_t elapsedTime = millis() - startTime;
  if (elapsedTime >= FADE_OUT_MS) {
    FastLED.setBrightness(0);
    stableShow();
    startTime = 0;
    return true;
  }
  
  uint8_t brightness = startBrightness * (FADE_OUT_MS - elapsedTime) / FADE_OUT_MS;
  FastLED.setBrightness(brightness);
  stableShow();
  return false;
}

// ä¿®æ”¹åçš„æ·¡å…¥æ•ˆæœ - ä½¿ç”¨å›ºå®šçš„èµ·å§‹è‰²è°ƒ
bool fadeIn() {
  static uint32_t startTime = 0;
  
  if (startTime == 0) {
    startTime = millis();
    // ä½¿ç”¨å›ºå®šçš„èµ·å§‹è‰²è°ƒï¼Œç¡®ä¿æ¯æ¬¡æ·¡å…¥éƒ½ä»ç›¸åŒä½ç½®å¼€å§‹
    startHue = 0; // é‡ç½®èµ·å§‹è‰²è°ƒ
    fill_rainbow(mainLeds, MAIN_NUM_LEDS, startHue, 255 / MAIN_NUM_LEDS);
    fill_rainbow(ringLeds, RING_NUM_LEDS, startHue + 64, 255 / RING_NUM_LEDS);
    
    // åˆå§‹åŒ–å…¨å±€è‰²è°ƒå˜é‡ï¼Œç¡®ä¿å¹³æ»‘è¿‡æ¸¡
    ringHue = startHue;
  }
  
  uint32_t elapsedTime = millis() - startTime;
  if (elapsedTime >= FADE_IN_MS) {
    FastLED.setBrightness(TARGET_BRIGHTNESS);
    stableShow();
    startTime = 0;
    return true;
  }
  
  uint8_t brightness = TARGET_BRIGHTNESS * elapsedTime / FADE_IN_MS;
  FastLED.setBrightness(brightness);
  
  // åœ¨æ·¡å…¥è¿‡ç¨‹ä¸­ä¿æŒé¢œè‰²ä¸å˜
  fill_rainbow(mainLeds, MAIN_NUM_LEDS, startHue, 255 / MAIN_NUM_LEDS);
  fill_rainbow(ringLeds, RING_NUM_LEDS, startHue + 64, 255 / RING_NUM_LEDS);
  
  stableShow();
  return false;
}

// è®¾ç½®æ‰‹åŠ¨é¢œè‰²
void setManualColor(uint8_t r, uint8_t g, uint8_t b) {
  manualRed = r;
  manualGreen = g;
  manualBlue = b;
  
  if (currentState == STATE_MANUAL) {
    fill_solid(mainLeds, MAIN_NUM_LEDS, CRGB(r, g, b));
    fill_solid(ringLeds, RING_NUM_LEDS, CRGB(r, g, b));
    FastLED.setBrightness(globalBrightness);
    stableShow();
  }
}

// è®¾ç½®äº®åº¦
void setBrightness(uint8_t brightness) {
  globalBrightness = brightness;
  TARGET_BRIGHTNESS = brightness;
  FastLED.setBrightness(brightness);
  stableShow();
 
  Serial.println( " äº®åº¦å·²è®¾ç½®ä¸º: " + String(brightness) + "%");
}

// è®¾ç½®æ¨¡å¼
void setMode(String mode) {
  Serial.println("è®¾ç½®æ¨¡å¼: " + mode);
  
  if (mode == "off") {
    currentState = STATE_OFF;
    FastLED.setBrightness(0);
    stableShow();
  } else if (mode == "breathe") {
    currentState = STATE_BREATHE_LOOP;
    breatheStep = 0;
  } else if (mode == "rainbow") {
    currentState = STATE_NORMAL;
    startHue = 0;
    ringHue = 0;
  } else if (mode == "manual") {
    currentState = STATE_MANUAL;
    setManualColor(manualRed, manualGreen, manualBlue);
  } else if (mode == "auto") {
    // æ¢å¤è‡ªåŠ¨æ¨¡å¼ï¼Œæ ¹æ®ä¼ æ„Ÿå™¨çŠ¶æ€å†³å®š
    currentMotionState = digitalRead(MOTION_SENSOR_PIN);
    if (currentMotionState) {
      currentState = STATE_BREATHE;
      breatheStep = 0;
    } else {
      currentState = STATE_OFF;
    }
  }
}

// å¿«é€Ÿæµ‹è¯•ç¯ç¯ï¼ˆéé˜»å¡ï¼‰
void quickTestLeds() {
  Serial.println("å¿«é€Ÿæµ‹è¯•ç¯ç¯...");
  
  // ä¸»ç¯ç¯å¿«é€Ÿæµ‹è¯• - è“è‰²
  fill_solid(mainLeds, MAIN_NUM_LEDS, CRGB::Blue);
  fill_solid(ringLeds, RING_NUM_LEDS, CRGB::Blue);
  FastLED.setBrightness(50);
  stableShow();
  delay(500);
  
  // ç»¿è‰²
  fill_solid(mainLeds, MAIN_NUM_LEDS, CRGB::Green);
  fill_solid(ringLeds, RING_NUM_LEDS, CRGB::Green);
  stableShow();
  delay(500);
  
  // çº¢è‰²
  fill_solid(mainLeds, MAIN_NUM_LEDS, CRGB::Red);
  fill_solid(ringLeds, RING_NUM_LEDS, CRGB::Red);
  stableShow();
  delay(500);
  
  // å…³é—­
  FastLED.setBrightness(0);
  FastLED.clear();
  stableShow();
  
  Serial.println("ç¯ç¯æµ‹è¯•å®Œæˆ");
}

// å¤„ç†æ ¹ç›®å½•è¯·æ±‚
void handleRoot() {
  Serial.println("æ”¶åˆ°ç½‘é¡µè¯·æ±‚");
  
  String html = R"rawliteral(
<!DOCTYPE HTML>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta charset='UTF-8'>
  <style>
    body { 
      font-family: Arial; 
      text-align: center; 
      margin: 0 auto; 
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }
    .container { 
      max-width: 400px; 
      margin: 0 auto; 
      background: rgba(255,255,255,0.1);
      padding: 20px;
      border-radius: 15px;
      backdrop-filter: blur(10px);
    }
    .btn { 
      background-color: #4CAF50; 
      border: none; 
      color: white; 
      padding: 12px 24px; 
      text-align: center; 
      text-decoration: none; 
      display: inline-block; 
      font-size: 16px; 
      margin: 4px 2px; 
      cursor: pointer; 
      border-radius: 8px;
      width: 100%;
    }
    .btn-off { background-color: #f44336; }
    .btn-auto { background-color: #2196F3; }
    .slider-container { 
      margin: 20px 0; 
      text-align: left;
    }
    .slider { 
      width: 100%; 
      height: 25px; 
      background: #ddd;
      outline: none;
      border-radius: 12px;
    }
    .color-picker {
      width: 100%;
      height: 50px;
      border: none;
      border-radius: 8px;
      margin: 10px 0;
    }
    .status {
      background: rgba(0,0,0,0.3);
      padding: 10px;
      border-radius: 8px;
      margin: 10px 0;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ’¡ LEDç¯å…‰æ§åˆ¶</h1>
    
    <div class="status">
      <p>IPåœ°å€: )rawliteral" + WiFi.localIP().toString() + R"rawliteral(</p>
      <p>çŠ¶æ€: <span id="status">)rawliteral" + 
      (currentState == STATE_OFF ? "å…³é—­" : 
       currentState == STATE_BREATHE ? "å‘¼å¸æ¨¡å¼" : 
       currentState == STATE_NORMAL ? "å½©è™¹æ¨¡å¼" : 
       currentState == STATE_MANUAL ? "æ‰‹åŠ¨è°ƒè‰²" : "è‡ªåŠ¨æ¨¡å¼") + 
      R"rawliteral(</span></p>
    </div>

    <h3>æ¨¡å¼é€‰æ‹©</h3>
    <button class="btn btn-off" onclick="setMode('off')">å…³é—­</button>
    <button class="btn" onclick="setMode('breathe')">å‘¼å¸æ¨¡å¼</button>
    <button class="btn" onclick="setMode('rainbow')">å½©è™¹æ¨¡å¼</button>
    <button class="btn" onclick="setMode('manual')">æ‰‹åŠ¨è°ƒè‰²</button>
    <button class="btn btn-auto" onclick="setMode('auto')">è‡ªåŠ¨æ¨¡å¼</button>

    <div class="slider-container">
      <h3>äº®åº¦æ§åˆ¶: <span id="brightnessValue">)rawliteral" + String(map(globalBrightness, 0, 255, 0, 100)) + R"rawliteral(</span>%</h3>
      <input type="range" min="0" max="100" value=")rawliteral" + String(map(globalBrightness, 0, 255, 0, 100)) + R"rawliteral(" class="slider" id="brightnessSlider" onchange="setBrightness(this.value)">
    </div>

    <div id="colorControl" style="display: )rawliteral" + (currentState == STATE_MANUAL ? "block" : "none") + R"rawliteral(;">
      <h3>é¢œè‰²é€‰æ‹©</h3>
      <input type="color" class="color-picker" id="colorPicker" onchange="setColor(this.value)" value="#ffffff">
    </div>
  </div>

  <script>
    function setMode(mode) {
      fetch('/control?mode=' + mode)
        .then(response => response.json())
        .then(data => {
          document.getElementById('status').innerText = data.status;
          document.getElementById('colorControl').style.display = 
            (mode === 'manual') ? 'block' : 'none';
        });
    }

    function setBrightness(value) {
      document.getElementById('brightnessValue').innerText = value;
      fetch('/control?brightness=' + value)
        .then(response => response.json());
    }

    function setColor(color) {
      const r = parseInt(color.substr(1,2), 16);
      const g = parseInt(color.substr(3,2), 16);
      const b = parseInt(color.substr(5,2), 16);
      fetch('/control?r=' + r + '&g=' + g + '&b=' + b)
        .then(response => response.json());
    }
  </script>
</body>
</html>
)rawliteral";

  server.send(200, "text/html", html);
}

// å¤„ç†æ§åˆ¶è¯·æ±‚
void handleControl() {
  Serial.println("æ”¶åˆ°æ§åˆ¶è¯·æ±‚");
  
  String message = "";
  
  if (server.hasArg("mode")) {
    String mode = server.arg("mode");
    setMode(mode);
    message = "æ¨¡å¼å·²è®¾ç½®ä¸º: " + mode;
  }
  
  if (server.hasArg("brightness")) {
    int brightness = server.arg("brightness").toInt();
    setBrightness(map(brightness, 0, 100, 0, 255));
    //message += " äº®åº¦å·²è®¾ç½®ä¸º: " + String(brightness) + "%";
  }
  
  if (server.hasArg("r") && server.hasArg("g") && server.hasArg("b")) {
    uint8_t r = server.arg("r").toInt();
    uint8_t g = server.arg("g").toInt();
    uint8_t b = server.arg("b").toInt();
    setManualColor(r, g, b);
    message += " é¢œè‰²å·²è®¾ç½®";
  }

  // è¿”å›JSONå“åº”
  String statusText = "";
  switch(currentState) {
    case STATE_OFF: statusText = "å…³é—­"; break;
    case STATE_BREATHE: statusText = "å‘¼å¸æ¨¡å¼"; break;
    case STATE_NORMAL: statusText = "å½©è™¹æ¨¡å¼"; break;
    case STATE_MANUAL: statusText = "æ‰‹åŠ¨è°ƒè‰²"; break;
    default: statusText = "è‡ªåŠ¨æ¨¡å¼"; break;
  }

  String json = "{\"status\":\"" + statusText + "\",\"message\":\"" + message + "\",\"brightness\":" + String(map(globalBrightness, 0, 255, 0, 100)) + "}";
  server.send(200, "application/json", json);
  
  Serial.println("æ§åˆ¶å“åº”: " + message);
}

// å¤„ç†æœªæ‰¾åˆ°çš„é¡µé¢
void handleNotFound() {
  String message = "File Not Found\n\n";
  message += "URI: ";
  message += server.uri();
  message += "\nMethod: ";
  message += (server.method() == HTTP_GET) ? "GET" : "POST";
  message += "\nArguments: ";
  message += server.args();
  message += "\n";
  for (uint8_t i = 0; i < server.args(); i++) {
    message += " " + server.argName(i) + ": " + server.arg(i) + "\n";
  }
  server.send(404, "text/plain", message);
}

void setup() {
  Serial.begin(115200);
  
  pinMode(BOARD_LED_PIN, OUTPUT);
  pinMode(MOTION_SENSOR_PIN, INPUT);
  
  Serial.println("====================================");
  Serial.println("åŒç¯ç¯ç³»ç»Ÿå¯åŠ¨ - WiFiæ§åˆ¶ç‰ˆ");
  Serial.println("====================================");
  
  // åˆå§‹åŒ–ä¸¤ä¸ªç¯ç¯
  FastLED.addLeds<CHIPSET, MAIN_LED_PIN, COLOR_ORDER>(mainLeds, MAIN_NUM_LEDS);
  FastLED.addLeds<CHIPSET, RING_LED_PIN, COLOR_ORDER>(ringLeds, RING_NUM_LEDS);
  
  // è®¾ç½®æ›´ä¿å®ˆçš„å‚æ•°
  FastLED.setBrightness(0);
  
  // åˆå§‹åŒ–æ‰€æœ‰LEDä¸ºé»‘è‰²
  FastLED.clear();
  stableShow();
  
  // åˆå§‹åŒ–è‰²è°ƒå˜é‡
  startHue = 0;
  ringHue = 0;
  
  // è¿æ¥WiFi
  Serial.println("æ­£åœ¨è¿æ¥WiFi...");
  Serial.print("SSID: ");
  Serial.println(ssid);
  
  // é…ç½®é™æ€IPï¼ˆå¯é€‰ï¼‰
  if (!WiFi.config(local_IP, gateway, subnet)) {
    Serial.println("STA Failed to configure");
  }
  
  WiFi.begin(ssid, password);
  
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 30) {
    delay(500);
    Serial.print(".");
    attempts++;
    digitalWrite(BOARD_LED_PIN, !digitalRead(BOARD_LED_PIN)); // é—ªçƒæŒ‡ç¤ºç¯
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    wifiConnected = true;
    Serial.println("\nWiFiè¿æ¥æˆåŠŸ!");
    Serial.print("IPåœ°å€: ");
    Serial.println(WiFi.localIP());
    digitalWrite(BOARD_LED_PIN, HIGH);
    
    // å¿«é€Ÿæµ‹è¯•ç¯ç¯
    quickTestLeds();
  } else {
    Serial.println("\nWiFiè¿æ¥å¤±è´¥ï¼Œä½¿ç”¨ç¦»çº¿æ¨¡å¼");
    digitalWrite(BOARD_LED_PIN, LOW);
    // å³ä½¿WiFiå¤±è´¥ä¹Ÿç»§ç»­è¿è¡Œ
    quickTestLeds();
  }
  
  // è®¾ç½®WebæœåŠ¡å™¨è·¯ç”±
  server.on("/", handleRoot);
  server.on("/control", handleControl);
  server.onNotFound(handleNotFound);
  
  server.begin();
  Serial.println("HTTPæœåŠ¡å™¨å·²å¯åŠ¨");
  Serial.println("è¯·ç”¨æµè§ˆå™¨è®¿é—®: http://" + WiFi.localIP().toString());
}

void loop() {
  // å¤„ç†å®¢æˆ·ç«¯è¯·æ±‚
  server.handleClient();
  
  // åªæœ‰åœ¨è‡ªåŠ¨æ¨¡å¼ä¸‹æ‰å¤„ç†äººä½“ä¼ æ„Ÿå™¨
  if (currentState != STATE_MANUAL && currentState != STATE_OFF) {
    // è¯»å–äººä½“æ£€æµ‹æ¨¡å—çŠ¶æ€
    currentMotionState = digitalRead(MOTION_SENSOR_PIN);
    
    // æ£€æµ‹åˆ°çŠ¶æ€å˜åŒ–
    if (currentMotionState != lastMotionState) {
      lastMotionState = currentMotionState;
      lastMotionTime = millis();
      
      if (currentMotionState) {
        Serial.println("ğŸš¶ æ£€æµ‹åˆ°äººä½“ç§»åŠ¨ï¼");
        digitalWrite(BOARD_LED_PIN, HIGH);
        
        if (currentState == STATE_OFF || currentState == STATE_FADE_OUT) {
          currentState = STATE_BREATHE;
          breatheStep = 0;
          // é‡ç½®è‰²è°ƒï¼Œç¡®ä¿æ¯æ¬¡é‡æ–°æ£€æµ‹éƒ½ä»ç›¸åŒä½ç½®å¼€å§‹
          startHue = 0;
          ringHue = 0;
        }
      } else {
        Serial.println("ğŸ’¤ æ— äººä½“ç§»åŠ¨");
        digitalWrite(BOARD_LED_PIN, LOW);
        
        if (currentState == STATE_NORMAL) {
          currentState = STATE_FADE_OUT;
        }
      }
    }
  }
  
  // çŠ¶æ€æœºå¤„ç†
  switch (currentState) {
    case STATE_OFF:
      // ä¿æŒå…³é—­çŠ¶æ€
      break;
      
    case STATE_BREATHE:
      if (breatheStep < BREATHE_STEPS) {
        FastLED.setBrightness(255);
        FastLED.clear();
        
        // ä¸»ç¯ç¯å‘¼å¸æ•ˆæœ
        uint8_t mainPos = (breatheStep < MAIN_NUM_LEDS) ? breatheStep : (2 * MAIN_NUM_LEDS - 1 - breatheStep);
        uint8_t mainBrightness;
        if (breatheStep < MAIN_NUM_LEDS) {
          mainBrightness = (uint16_t)breatheStep * 255 / MAIN_NUM_LEDS;
        } else {
          mainBrightness = (uint16_t)(BREATHE_STEPS - breatheStep) * 255 / MAIN_NUM_LEDS;
        }
        mainLeds[mainPos] = CRGB(mainBrightness, mainBrightness, mainBrightness);
        
        // ç¯å½¢ç¯ç¯åŒæ­¥å‘¼å¸æ•ˆæœ
        uint8_t ringPos = (breatheStep * RING_NUM_LEDS) / BREATHE_STEPS;
        ringPos = ringPos % RING_NUM_LEDS;
        fill_solid(ringLeds, RING_NUM_LEDS, CRGB::Black);
        ringLeds[ringPos] = CRGB(mainBrightness, mainBrightness, mainBrightness);
        
        stableShow();
        delay(STEP_DELAY);
        breatheStep++;
      } else {
        currentState = STATE_FADE_IN;
        // ç¡®ä¿æ·¡å…¥æ•ˆæœä½¿ç”¨å›ºå®šçš„èµ·å§‹è‰²è°ƒ
        startHue = 0;
      }
      break;
    
    case STATE_BREATHE_LOOP: {
      FastLED.clear();
      
      uint16_t currentStep = breatheStep % BREATHE_STEPS;
      
      // ä¸»ç¯ç¯ï¼šä¸€ä¸ªæœ€äº®çš„ç¯ç å¾ªç¯ç§»åŠ¨
      uint8_t mainPos = currentStep % MAIN_NUM_LEDS;  // ç®€å•çš„å¾ªç¯
      
      // ç¯å½¢ç¯ï¼šåŒæ­¥å¾ªç¯ç§»åŠ¨
      uint8_t ringPos = currentStep % RING_NUM_LEDS;
      
      // è®¾ç½®æœ€äº®ç™½è‰²
      mainLeds[mainPos] = CRGB::White;
      fill_solid(ringLeds, RING_NUM_LEDS, CRGB::Black);
      ringLeds[ringPos] = CRGB::White;
      
      stableShow();
      delay(STEP_DELAY);
      breatheStep++;
      break;
    }

    case STATE_FADE_IN:
      if (fadeIn()) {
        currentState = STATE_NORMAL;
        lastModeChangeTime = millis();
        // ä»æ·¡å…¥çš„å›ºå®šè‰²è°ƒå¹³æ»‘è¿‡æ¸¡åˆ°æµåŠ¨å½©è™¹
        ringHue = startHue; // ç¡®ä¿è‰²è°ƒè¿ç»­
      }
      break;
      
    case STATE_NORMAL:
      {
        unsigned long currentMillis = millis();
        if (currentMillis - previousMillis >= NORMAL_UPDATE_INTERVAL) {
          previousMillis = currentMillis;
          
          // ä½¿ç”¨å…¨å±€è‰²è°ƒå˜é‡ï¼Œç¡®ä¿ä»æ·¡å…¥æ•ˆæœå¹³æ»‘è¿‡æ¸¡
          fill_rainbow(mainLeds, MAIN_NUM_LEDS, ringHue, 255 / MAIN_NUM_LEDS);
          fill_rainbow(ringLeds, RING_NUM_LEDS, ringHue + 64, 255 / RING_NUM_LEDS);
          ringHue += 2; // ç¨å¾®å‡æ…¢å˜åŒ–é€Ÿåº¦ï¼Œä½¿è¿‡æ¸¡æ›´å¹³æ»‘
          
          stableShow();
        }
      }
      break;
      
    case STATE_FADE_OUT:
      if (fadeOut()) {
        currentState = STATE_OFF;
        breatheStep = 0;
      }
      break;
      
    case STATE_MANUAL:
      // æ‰‹åŠ¨æ¨¡å¼ä¸‹ï¼Œé¢œè‰²å’Œäº®åº¦é€šè¿‡ç½‘é¡µæ§åˆ¶ï¼Œè¿™é‡Œä¸éœ€è¦é¢å¤–å¤„ç†
      break;
  }
  
  // å¦‚æœæ£€æµ‹åˆ°ç§»åŠ¨ï¼Œå®šæœŸè¾“å‡ºçŠ¶æ€
  if (currentMotionState && currentState != STATE_MANUAL) {
    unsigned long currentTime = millis();
    if (currentTime - lastMotionTime > 5000) {
      Serial.println("ğŸ“ äººä½“ä»åœ¨æ£€æµ‹èŒƒå›´å†…");
      lastMotionTime = currentTime;
    }
  }
}