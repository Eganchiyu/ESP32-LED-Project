#include "LED_Controller.h"
#include <ArduinoJson.h>

// 定义所有全局变量
WebServer server(80);
SystemState currentState = STATE_OFF;
bool lastMotionState = false;
bool currentMotionState = false;
unsigned long lastMotionTime = 0;
uint16_t breatheStep = 0;
uint8_t startHue = 0;
uint8_t ringHue = 0;

// 定义LED数组
CRGB mainLeds[MAIN_NUM_LEDS];
CRGB ringLeds[RING_NUM_LEDS];

// 其他变量
unsigned long lastModeChangeTime = 0;
uint8_t ringMode = 0;
uint8_t manualRed = 255;
uint8_t manualGreen = 255;
uint8_t manualBlue = 255;
bool manualModeActive = false;
unsigned long previousMillis = 0;
uint8_t globalBrightness = 80;
uint8_t TARGET_BRIGHTNESS = 80;

void stableShow() {
  delayMicroseconds(50);
  FastLED.show();
  delayMicroseconds(50);
}

bool fadeOut() {
  static uint32_t startTime = 0;
  static uint8_t startBrightness = 0;
  
  if (startTime == 0) {
    startTime = millis();
    startBrightness = FastLED.getBrightness();
  }
  
  uint32_t elapsedTime = millis() - startTime;
  if (elapsedTime >= FADE_OUT_MS) {
    FastLED.setBrightness(0);
    stableShow();
    startTime = 0;
    return true;
  }
  
  uint8_t brightness = startBrightness * (FADE_OUT_MS - elapsedTime) / FADE_OUT_MS;
  FastLED.setBrightness(brightness);
  stableShow();
  return false;
}

bool fadeIn() {
  static uint32_t startTime = 0;
  
  if (startTime == 0) {
    startTime = millis();
    startHue = 0;
    fill_rainbow(mainLeds, MAIN_NUM_LEDS, startHue, 255 / MAIN_NUM_LEDS);
    fill_rainbow(ringLeds, RING_NUM_LEDS, startHue + 64, 255 / RING_NUM_LEDS);
    ringHue = startHue;
  }
  
  uint32_t elapsedTime = millis() - startTime;
  if (elapsedTime >= FADE_IN_MS) {
    FastLED.setBrightness(TARGET_BRIGHTNESS);
    stableShow();
    startTime = 0;
    return true;
  }
  
  uint8_t brightness = TARGET_BRIGHTNESS * elapsedTime / FADE_IN_MS;
  FastLED.setBrightness(brightness);
  fill_rainbow(mainLeds, MAIN_NUM_LEDS, startHue, 255 / MAIN_NUM_LEDS);
  fill_rainbow(ringLeds, RING_NUM_LEDS, startHue + 64, 255 / RING_NUM_LEDS);
  stableShow();
  return false;
}

void setManualColor(uint8_t r, uint8_t g, uint8_t b) {
  manualRed = r;
  manualGreen = g;
  manualBlue = b;
  
  if (currentState == STATE_MANUAL) {
    fill_solid(mainLeds, MAIN_NUM_LEDS, CRGB(r, g, b));
    fill_solid(ringLeds, RING_NUM_LEDS, CRGB(r, g, b));
    FastLED.setBrightness(globalBrightness);
    stableShow();
  }
}

void setBrightness(uint8_t brightness) {
  globalBrightness = brightness;
  TARGET_BRIGHTNESS = brightness;
  FastLED.setBrightness(brightness);
  stableShow();
  Serial.println("亮度已设置为: " + String(brightness) + "%");
}

void setMode(String mode) {
  Serial.println("设置模式: " + mode);
  
  if (mode == "off") {
    currentState = STATE_OFF;
    FastLED.setBrightness(0);
    stableShow();
  } else if (mode == "breathe") {
    currentState = STATE_BREATHE_LOOP;
    breatheStep = 0;
  } else if (mode == "rainbow") {
    currentState = STATE_NORMAL;
    startHue = 0;
    ringHue = 0;
  } else if (mode == "manual") {
    currentState = STATE_MANUAL;
    setManualColor(manualRed, manualGreen, manualBlue);
  } else if (mode == "auto") {
    currentMotionState = digitalRead(MOTION_SENSOR_PIN);
    if (currentMotionState) {
      currentState = STATE_BREATHE;
      breatheStep = 0;
    } else {
      currentState = STATE_OFF;
    }
  }
}

void quickTestLeds() {
  Serial.println("快速测试灯环...");
  
  fill_solid(mainLeds, MAIN_NUM_LEDS, CRGB::Blue);
  fill_solid(ringLeds, RING_NUM_LEDS, CRGB::Blue);
  FastLED.setBrightness(50);
  stableShow();
  delay(500);
  
  fill_solid(mainLeds, MAIN_NUM_LEDS, CRGB::Green);
  fill_solid(ringLeds, RING_NUM_LEDS, CRGB::Green);
  stableShow();
  delay(500);
  
  fill_solid(mainLeds, MAIN_NUM_LEDS, CRGB::Red);
  fill_solid(ringLeds, RING_NUM_LEDS, CRGB::Red);
  stableShow();
  delay(500);
  
  FastLED.setBrightness(0);
  FastLED.clear();
  stableShow();
  
  Serial.println("灯环测试完成");
}

void handleRoot() {
  // 网页HTML代码（与原来相同）
  // 这里可以进一步精简，但为了保持完整我先保留
  String html = R"rawliteral( ... )rawliteral";
  server.send(200, "text/html", html);
}

void handleControl() {
  Serial.println("收到控制请求");
  
  String message = "";
  
  if (server.hasArg("mode")) {
    String mode = server.arg("mode");
    setMode(mode);
    message = "模式已设置为: " + mode;
  }
  
  if (server.hasArg("brightness")) {
    int brightness = server.arg("brightness").toInt();
    setBrightness(map(brightness, 0, 100, 0, 255));
  }
  
  if (server.hasArg("r") && server.hasArg("g") && server.hasArg("b")) {
    uint8_t r = server.arg("r").toInt();
    uint8_t g = server.arg("g").toInt();
    uint8_t b = server.arg("b").toInt();
    setManualColor(r, g, b);
    message += " 颜色已设置";
  }

  String statusText = "";
  switch(currentState) {
    case STATE_OFF: statusText = "关闭"; break;
    case STATE_BREATHE: statusText = "呼吸模式"; break;
    case STATE_NORMAL: statusText = "彩虹模式"; break;
    case STATE_MANUAL: statusText = "手动调色"; break;
    default: statusText = "自动模式"; break;
  }

  String json = "{\"status\":\"" + statusText + "\",\"message\":\"" + message + "\",\"brightness\":" + String(map(globalBrightness, 0, 255, 0, 100)) + "}";
  server.send(200, "application/json", json);
  
  Serial.println("控制响应: " + message);
}

void handleNotFound() {
  String message = "File Not Found\n\n";
  message += "URI: ";
  message += server.uri();
  message += "\nMethod: ";
  message += (server.method() == HTTP_GET) ? "GET" : "POST";
  message += "\nArguments: ";
  message += server.args();
  message += "\n";
  for (uint8_t i = 0; i < server.args(); i++) {
    message += " " + server.argName(i) + ": " + server.arg(i) + "\n";
  }
  server.send(404, "text/plain", message);
}

void setupLEDs() {
  FastLED.addLeds<CHIPSET, MAIN_LED_PIN, COLOR_ORDER>(mainLeds, MAIN_NUM_LEDS);
  FastLED.addLeds<CHIPSET, RING_LED_PIN, COLOR_ORDER>(ringLeds, RING_NUM_LEDS);
  FastLED.setBrightness(0);
  FastLED.clear();
  stableShow();
}

void updateLEDs() {
  // 状态机处理
  switch (currentState) {
    case STATE_OFF:
      break;
      
    case STATE_BREATHE:
      if (breatheStep < BREATHE_STEPS) {
        FastLED.setBrightness(255);
        FastLED.clear();
        
        uint8_t mainPos = (breatheStep < MAIN_NUM_LEDS) ? breatheStep : (2 * MAIN_NUM_LEDS - 1 - breatheStep);
        uint8_t mainBrightness;
        if (breatheStep < MAIN_NUM_LEDS) {
          mainBrightness = (uint16_t)breatheStep * 255 / MAIN_NUM_LEDS;
        } else {
          mainBrightness = (uint16_t)(BREATHE_STEPS - breatheStep) * 255 / MAIN_NUM_LEDS;
        }
        mainLeds[mainPos] = CRGB(mainBrightness, mainBrightness, mainBrightness);
        
        uint8_t ringPos = (breatheStep * RING_NUM_LEDS) / BREATHE_STEPS;
        ringPos = ringPos % RING_NUM_LEDS;
        fill_solid(ringLeds, RING_NUM_LEDS, CRGB::Black);
        ringLeds[ringPos] = CRGB(mainBrightness, mainBrightness, mainBrightness);
        
        stableShow();
        delay(BREATHE_DURATION_MS / BREATHE_STEPS);
        breatheStep++;
      } else {
        currentState = STATE_FADE_IN;
        startHue = 0;
      }
      break;
    
    case STATE_BREATHE_LOOP: {
      FastLED.clear();
      
      uint16_t currentStep = breatheStep % BREATHE_STEPS;
      uint8_t mainPos = currentStep % MAIN_NUM_LEDS;
      uint8_t ringPos = currentStep % RING_NUM_LEDS;
      
      mainLeds[mainPos] = CRGB::White;
      fill_solid(ringLeds, RING_NUM_LEDS, CRGB::Black);
      ringLeds[ringPos] = CRGB::White;
      
      stableShow();
      delay(BREATHE_DURATION_MS / BREATHE_STEPS);
      breatheStep++;
      break;
    }

    case STATE_FADE_IN:
      if (fadeIn()) {
        currentState = STATE_NORMAL;
        lastModeChangeTime = millis();
        ringHue = startHue;
      }
      break;
      
    case STATE_NORMAL:
      {
        unsigned long currentMillis = millis();
        if (currentMillis - previousMillis >= NORMAL_UPDATE_INTERVAL) {
          previousMillis = currentMillis;
          fill_rainbow(mainLeds, MAIN_NUM_LEDS, ringHue, 255 / MAIN_NUM_LEDS);
          fill_rainbow(ringLeds, RING_NUM_LEDS, ringHue + 64, 255 / RING_NUM_LEDS);
          ringHue += 2;
          stableShow();
        }
      }
      break;
      
    case STATE_FADE_OUT:
      if (fadeOut()) {
        currentState = STATE_OFF;
        breatheStep = 0;
      }
      break;
      
    case STATE_MANUAL:
      break;
  }
}